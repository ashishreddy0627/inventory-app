package com.example.inventory_app.controller;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.example.inventory_app.dto.PurchaseRequest;
import com.example.inventory_app.dto.ReorderItemResponse;
import com.example.inventory_app.dto.SaleRequest;
import com.example.inventory_app.dto.StockAdjustmentRequest;
import com.example.inventory_app.entity.AppUser;
import com.example.inventory_app.entity.Item;
import com.example.inventory_app.entity.Store;
import com.example.inventory_app.entity.StockTransaction;
import com.example.inventory_app.entity.TransactionType;
import com.example.inventory_app.repository.AppUserRepository;
import com.example.inventory_app.repository.ItemRepository;
import com.example.inventory_app.repository.StockTransactionRepository;
import com.example.inventory_app.repository.StoreRepository;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = "http://localhost:3000")
public class InventoryController {

    private final ItemRepository itemRepository;
    private final StoreRepository storeRepository;
    private final AppUserRepository appUserRepository;
    private final StockTransactionRepository transactionRepository;

    public InventoryController(
            ItemRepository itemRepository,
            StoreRepository storeRepository,
            AppUserRepository appUserRepository,
            StockTransactionRepository transactionRepository) {
        this.itemRepository = itemRepository;
        this.storeRepository = storeRepository;
        this.appUserRepository = appUserRepository;
        this.transactionRepository = transactionRepository;
    }

    // ---------- STORES ----------

    @GetMapping("/stores")
    public List<Store> getAllStores() {
        return storeRepository.findAll();
    }

    @PostMapping("/stores")
    public Store createStore(@RequestBody Store store) {
        store.setIsActive(true);

        AppUser owner = appUserRepository.findByEmail("owner@example.com")
                .orElseThrow(() -> new IllegalStateException("default owner user not found"));
        store.setOwner(owner);
        return storeRepository.save(store);
    }

    // ---------- ITEMS ----------

    @GetMapping("/items")
    public List<Item> getAllItems() {
        return itemRepository.findAll();
    }

    @GetMapping("/stores/{storeId}/items")
    public List<Item> getItemsByStore(@PathVariable Long storeId) {
        return itemRepository.findByStoreId(storeId);
    }

    @PostMapping("/items")
    public Item createItem(@RequestBody Item item) {
        if (item.getStoreId() == null) {
            item.setStoreId(1L); // default to store 1 if not provided
        }
        if (item.getIsActive() == null) {
            item.setIsActive(true);
        }
        if (item.getCurrentStock() == null) {
            item.setCurrentStock(0);
        }
        if (item.getReorderLevel() == null) {
            item.setReorderLevel(0);
        }
        if (item.getTargetStock() == null) {
            item.setTargetStock(0);
        }

        return itemRepository.save(item);
    }

    @PostMapping("/stores/{storeId}/items")
    public Item createItemForStore(@PathVariable Long storeId, @RequestBody Item item) {
        item.setStoreId(storeId);
        if (item.getIsActive() == null) {
            item.setIsActive(true);
        }
        if (item.getCurrentStock() == null) {
            item.setCurrentStock(0);
        }
        if (item.getReorderLevel() == null) {
            item.setReorderLevel(0);
        }
        if (item.getTargetStock() == null) {
            item.setTargetStock(0);
        }

        return itemRepository.save(item);
    }

    // ---------- STOCK ADJUSTMENTS (NEW UNIFIED ENDPOINT) ----------

    @PostMapping("/items/{itemId}/adjust-stock")
    public ResponseEntity<?> adjustStock(@PathVariable Long itemId, @RequestBody StockAdjustmentRequest request) {
        Optional<Item> itemOpt = itemRepository.findById(itemId);
        if (itemOpt.isEmpty()) {
            return ResponseEntity.badRequest().body("Item not found");
        }

        Item item = itemOpt.get();
        Integer currentStock = item.getCurrentStock() != null ? item.getCurrentStock() : 0;

        // Validate quantity
        if (request.getQuantity() == null || request.getQuantity() == 0) {
            return ResponseEntity.badRequest().body("Quantity cannot be zero");
        }

        // For sales (negative quantity), check if we have enough stock
        if (request.getQuantity() < 0 && currentStock < Math.abs(request.getQuantity())) {
            return ResponseEntity.badRequest().body("Not enough stock. Current: " + currentStock);
        }

        // Calculate new stock
        Integer newStock = currentStock + request.getQuantity();

        // Log the transaction
        StockTransaction transaction = new StockTransaction();
        transaction.setItemId(itemId);
        transaction.setStoreId(item.getStoreId());
        transaction.setType(request.getType() != null ? request.getType() : 
                            (request.getQuantity() > 0 ? TransactionType.DELIVERY : TransactionType.SALE));
        transaction.setQuantity(request.getQuantity());
        transaction.setStockBefore(currentStock);
        transaction.setStockAfter(newStock);
        transaction.setNotes(request.getNotes());
        transaction.setTransactionDate(LocalDateTime.now());

        transactionRepository.save(transaction);

        // Update item stock
        item.setCurrentStock(newStock);
        itemRepository.save(item);

        return ResponseEntity.ok(item);
    }

    // ---------- LEGACY TRANSACTION ENDPOINTS (kept for backward compatibility) ----------

    @PostMapping("/transactions/sale")
    public ResponseEntity<?> recordSale(@RequestBody SaleRequest request) {
        if (request.getItemId() == null || request.getQuantity() == null || request.getQuantity() <= 0) {
            return ResponseEntity.badRequest().body("itemId and positive quantity are required");
        }

        Optional<Item> itemOpt = itemRepository.findById(request.getItemId());
        if (itemOpt.isEmpty()) {
            return ResponseEntity.badRequest().body("Item not found");
        }

        Item item = itemOpt.get();
        Integer currentStock = item.getCurrentStock() != null ? item.getCurrentStock() : 0;

        if (currentStock < request.getQuantity()) {
            return ResponseEntity.badRequest().body("Not enough stock");
        }

        Integer newStock = currentStock - request.getQuantity();

        // Log the transaction
        StockTransaction transaction = new StockTransaction();
        transaction.setItemId(item.getId());
        transaction.setStoreId(item.getStoreId());
        transaction.setType(TransactionType.SALE);
        transaction.setQuantity(-request.getQuantity()); // Negative for sale
        transaction.setStockBefore(currentStock);
        transaction.setStockAfter(newStock);
        transaction.setTransactionDate(LocalDateTime.now());

        transactionRepository.save(transaction);

        // Update item
        item.setCurrentStock(newStock);
        itemRepository.save(item);

        return ResponseEntity.ok(item);
    }

    @PostMapping("/transactions/purchase")
    public ResponseEntity<?> recordPurchase(@RequestBody PurchaseRequest request) {
        if (request.getItemId() == null || request.getQuantity() == null || request.getQuantity() <= 0) {
            return ResponseEntity.badRequest().body("itemId and positive quantity are required");
        }

        Optional<Item> itemOpt = itemRepository.findById(request.getItemId());
        if (itemOpt.isEmpty()) {
            return ResponseEntity.badRequest().body("Item not found");
        }

        Item item = itemOpt.get();
        Integer currentStock = item.getCurrentStock() != null ? item.getCurrentStock() : 0;
        Integer newStock = currentStock + request.getQuantity();

        // Log the transaction
        StockTransaction transaction = new StockTransaction();
        transaction.setItemId(item.getId());
        transaction.setStoreId(item.getStoreId());
        transaction.setType(TransactionType.DELIVERY);
        transaction.setQuantity(request.getQuantity()); // Positive for delivery
        transaction.setStockBefore(currentStock);
        transaction.setStockAfter(newStock);
        transaction.setTransactionDate(LocalDateTime.now());

        transactionRepository.save(transaction);

        // Update item
        item.setCurrentStock(newStock);
        itemRepository.save(item);

        return ResponseEntity.ok(item);
    }

    // ---------- TRANSACTION HISTORY ----------

    @GetMapping("/items/{itemId}/transactions")
    public List<StockTransaction> getItemTransactions(@PathVariable Long itemId) {
        return transactionRepository.findByItemIdOrderByTransactionDateDesc(itemId);
    }

    @GetMapping("/stores/{storeId}/transactions")
    public List<StockTransaction> getStoreTransactions(@PathVariable Long storeId) {
        return transactionRepository.findByStoreIdOrderByTransactionDateDesc(storeId);
    }

    @GetMapping("/stores/{storeId}/items/{itemId}/transactions")
    public List<StockTransaction> getStoreItemTransactions(
            @PathVariable Long storeId,
            @PathVariable Long itemId) {
        return transactionRepository.findByStoreIdAndItemIdOrderByTransactionDateDesc(storeId, itemId);
    }

    // ---------- REORDER LIST ----------

    @GetMapping("/reorder-list")
    public List<ReorderItemResponse> getReorderListForAllStores() {
        List<Item> items = itemRepository.findAll();
        return buildReorderList(items);
    }

    @GetMapping("/stores/{storeId}/reorder-list")
    public List<ReorderItemResponse> getReorderListForStore(@PathVariable Long storeId) {
        List<Item> items = itemRepository.findByStoreId(storeId);
        return buildReorderList(items);
    }

    private List<ReorderItemResponse> buildReorderList(List<Item> items) {
        List<ReorderItemResponse> result = new ArrayList<>();

        for (Item item : items) {
            Integer current = item.getCurrentStock() != null ? item.getCurrentStock() : 0;
            Integer reorderLevel = java.util.Objects.requireNonNullElse(item.getReorderLevel(), 0);
            Integer target = item.getTargetStock() != null ? item.getTargetStock() : 0;

            if (current <= reorderLevel && target > current) {
                ReorderItemResponse dto = new ReorderItemResponse();
                dto.setItemId(item.getId());
                dto.setName(item.getName());
                dto.setCurrentStock(current);
                dto.setReorderLevel(reorderLevel);
                dto.setTargetStock(target);
                dto.setReorderQuantity(target - current);
                result.add(dto);
            }
        }

        return result;
    }

    // ---------- BARCODE LOOKUP ----------

    @GetMapping("/stores/{storeId}/items/by-barcode/{barcode}")
    public ResponseEntity<Item> getItemByBarcode(
            @PathVariable Long storeId,
            @PathVariable String barcode) {

        Optional<Item> itemOpt = itemRepository.findByBarcode(barcode);
        return itemOpt.map(ResponseEntity::ok)
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}